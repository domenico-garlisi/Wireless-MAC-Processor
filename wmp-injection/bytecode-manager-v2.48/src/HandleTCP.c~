#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <dirent.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>

#include "HandleTCP.h"
#include "messageHandler.h"


#define RCVBUFSIZE 1500
#define MAX_MESSAGE_SIZE 4096

#define MAXPENDING 5    /* Maximum outstanding connection requests */

int TCPClient(char *servIP, unsigned short servPort, char * message){

	int send_status = 0;
        char recvBuffer[32]="";
	unsigned int messageLen;      
	int sock;                        /* Socket descriptor */
	struct sockaddr_in servAddr; 	/* server address */

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0){
		printf("socket() failed");
		exit(1);
	}

	memset(&servAddr, 0, sizeof(servAddr));     // Zero out structure 
	servAddr.sin_family      = AF_INET;             // Internet address family 
	
	servAddr.sin_addr.s_addr = inet_addr(servIP);   // Server IP address 
	servAddr.sin_port        = htons(servPort); // Server port 
	// Establish the connection to the echo server 
	//fprintf(stdout,"TCP Connection to server %s PORT %d\n\n\n",servIP, servPort);

	if ((connect(sock, (struct sockaddr *) &servAddr, sizeof(servAddr))) < 0){
		fprintf(stderr, "TCP connection failed to server %s port %u\n",servIP,servPort);
		perror("connect() failed");
		exit(1);
	}


       send_status = write(sock, message, strlen(message));
       shutdown(sock, SHUT_WR); //GARANTISCE L ESCAPE!
       read(sock, recvBuffer, 11);
       printf("recvBuffer = %s\n",recvBuffer);
       close(sock);    /* Close client socket */
       return send_status;
}



